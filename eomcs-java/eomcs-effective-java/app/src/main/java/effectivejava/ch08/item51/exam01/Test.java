// # 아이템 51. 메서드 시그너처를 신중히 설계하라
//
package effectivejava.ch08.item51.exam01;

// [주제] 메서드 시그너처 설계 가이드라인
// 1) 메서드 이름을 신중히 짓자.
//    - 항상 표준 명명 규칙(Item 68)을 따라야 한다.
//    - 이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는 게 최우선이다.
//    - 개발자 커뮤니티에서 널리 받아들여진 이름을 사용하라.
//    - 긴 이름을 피하자. 애매하면 자바 라이브러리 API 가이드를 참조하라.
// 2) 편의 메서드를 너무 많이 만들지 말자.
//    - 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다.
//    - 클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 한다.
//    - 확신이 서지 않으면 만들지 말자.
// 3) 매개변수 목록은 짧게 유지하자.
//    - 4개 이하가 좋다.
//    - 같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.
// 4) 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다.
//    - 매개변수로 적합한 인터페이스가 있다면 그 인터페이스를 직접 사용하자.
//      예) m(HashMap)보다는 m(Map)
//    - 클래스를 사용하면 클라이언트에게 특정 구현체만 사용하도록 제한하는 셈이 된다.
// 5) boolean보다는 원소 2개짜리 열거 타입이 낫다.
//    - 열거 타입을 사용하면 코드를 읽고 쓰기가 더 쉽다.
//    - 나중에 선택지를 추가하기도 쉽다.
//      예) enum TemperatureScale { FAHRENHEIT, CELSIUS }
//      추후 캘빈온도도 지원해야 한다면, 열거 타입에 캘빈온도(KELVIN)를 추가하기만 하면 된다.
//    - 열거 타입을 사용하면, 개별 열거 타입 상수에 메서드를 넣을 수도 있다.
//      예) 각 온도를 나타내는 열거 타입 상수에 double 값을 받아 섭씨 온도로 변환해주는 메서드를 넣을 수 있다.
//

// [과하게 긴 매개변수 목록을 짧게 줄여주는 기술 3가지]
// 1) 여러 메서드로 쪼갠다.
//    - 쪼개진 메서드 각각은 원래 매개변수 목록의 부분 집합을 받는다.
//    - 메서드가 많아지는 문제는 있지만, 직교성(orthogonality)을 높혀
//      오히려 메서드 수를 줄여주는 효과도 있다.
// 2) 매개변수 여러 개를 묶어주는 도우미 클래스를 만든다.
//    - 매개변수 몇 개를 하나의 독립된 개념으로 볼 수 있을 때 유용하다.
//      예: 카드게임(숫자, 무늬), 좌표 쌍(x, y), 범위(시작, 끝), 복소수(실수부, 허수부) 등
//    - 도우미 클래스를 만들어 하나의 매개변수로 주고 받으면 API는 물론 내부 구현도 깔끔해진다.
// 3) 앞의 두 가지 방법을 혼합한 것으로, 빌더 패턴을 메서드 호출에 응용한다.
//    - 매개변수가 많고, 그 중 일부는 생략해도 괜찮을 때 도움이 된다.
//    - 모든 매개변수를 추상화한 객체를 정의
//      --> 이 객체의 setter를 호출해 필요한 값을 설정
//      --> execute() 같은 메서드를 호출해 앞서 설정한 매개변수들의 유효성을 검사
//      --> 설정이 완료된 객체를 넘겨 원하는 계산을 수행

// [직교성(orthogonality)]
// - 수학에서 온 용어로 서로 직각을 이루며 교차한다는 뜻이다.
//   수학 관점에서 직교하는 요소들은 서로 독립적이다.
// - '직교성이 높다'의 의미:
//   "공통점이 없는 기능들이 잘 분리되어 있다"
//   "기능을 원자적으로 쪼개 제공한다"
// - '직교성을 높혀 오히려 메서드 수를 줄여주는 효과도 있다'의 의미:
//   기능을 원자적으로 쪼개다 보면, 자연스럽게 중복이 줄고 결합성이 낮아져 코드를 수정하기 수월해진다.
//   기본 기능을 잘만 갖춰놓으면 아무리 복잡한 기능도 조합해낼 수 있다.
//   마치 화학의 원소를 가지고 조립하여 다양한 물질을 만들어내는 것과 비슷하다.
//   테스트하기 쉬워지고, 가볍고 구현하기 쉽고 유연하고 강력하다.
//
// [직교성이 낮은 경우]
// - 편의성을 높인다는 생각에 고수준의 복잡한 기능(직교성이 낮은 기능)을 하나씩 추가하다 보면,
//   부지불식간에 눈덩이처럼 커진 API가 만들어질 수 있다.
// - 특정 조합(원자적 기능의 조합)의 패턴이 상당히 자주 사용되거나 최적화하여 선능을 개선할 수 있다면,
//   직교성이 낮아지더라도 편의기능을 제공하는 편이 나을 수도 있다.

import java.util.List;

public class Test {
  public static void main(String[] args) {
    // 인덱스 2부터 10까지의 이름들 중에서 '장길산'의 인덱스를 찾는 경우
    List<String> names =
        List.of(
            "홍길동", "김삿갓", "이몽룡", "성춘향", "임꺽정", "장길산", "박문수", "변학도", "황진이", "심청이", "춘향이", "콩쥐", "팥쥐",
            "흥부", "놀부");

    // [직교성이 낮은 예]
    // - 서브리스트의 시작인덱스와 끝인덱스, 그리고 찾고자 하는 이름을 모두 한 메서드에 넘겨야 한다.
    //    names.indexOfFromSubList("장길산", 2, 11);

    // [직교성이 높은 예]
    // - 먼저 시작인덱스와 끝인덱스를 사용하여 서브리스트를 얻는 메서드를 호출한다.
    List<String> subList = names.subList(2, 11);
    // - 그런 다음 이름으로 서브리스트에서 인덱스를 찾는다.
    int index = subList.indexOf("장길산");

    System.out.println(names.get(index + 2));

    // [정리]
    // - 이렇게 파라미터를 여러 메서드로 나누면 직교성이 높아져
    //   메서드의 재사용성도 높아진다.
  }
}
