// # 아이템 53. 가변인수는 신중히 사용하라
// [가변인수(varargs) 메서드]
// - 명시한 타입의 아규먼트를 0개 이상 받을 수 있다.
// - 가변인수 메서드를 호출하면,
//   가장 먼저 아규먼트의 개수와 길이가 같은 배열을 만들고, 이 배열에 저장하여 메서드에 전네준다.
// - 아규먼트 개수가 일정하지 않을 경우 유용하다.
// - 필수 파라미터는 가변인수 앞에 두고, 가변인수를 사용할 때 성능 문제까지 고려하자.
//

package effectivejava.ch08.item53.exam04;

// [주제] 성능이 민감한 경우 가변인수 메서드를 작성하는 방법

public class Test {

  // 가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화해야한다.
  // 성능에 민감한 경우 이런 오버헤드가 부담스러울 수 있다.
  // 이런 경우에는 자주 호출되는 아규먼트 개수에 대해 다중정의 메서드를 제공하라.

  // 1) 메서드 호출의 95%가 아규먼트를 3개 이하로 전달하는 경우
  static void foo() {}

  static void foo(int a1) {}

  static void foo(int a1, int a2) {}

  static void foo(int a1, int a2, int a3) {}

  // 2) 3개 초과 아규먼트를 전달하는 경우에만 가변인수 메서드를 호출한다.
  static void foo(int a1, int a2, int a3, int... rest) {}

  public static void main(String[] args) {
    foo();
    foo(1);
    foo(1, 2);
    foo(1, 2, 3);
    foo(1, 2, 3, 4); // 가변인수 메서드 호출
    foo(1, 2, 3, 4, 5); // 가변인수 메서드 호출

    // [정리]
    // - 위 예의 경우 5%만이 배열을 생성하기 때문에 성능 오버헤드가 크게 줄어든다.
    // - EnumSet의 정적 팩토리도 이 기법을 사용해 열거 타입 집합 생성 비용을 최소화한다.
  }
}
