// # 아이템 18. 상속보다는 컴포지션을 사용하라
// - 상속은 코드를 재사용하는 강력한 수단이지만, 남용하면 오히려 해가 된다.
// - 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이다.
// - 확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 안전하다.
// - 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 사용하라.
//   하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다.
// - 상속의 취약점을 피하는 방법은 컴포지션과 전달을 사용하는 것이다.
//
// [상속이 위험한 경우] 다른 패키지의 구체(concrete) 클래스를 상속할 때
// 1) 내부 구현을 알 수 없음
//    부모 클래스의 private 필드, protected 메서드, 호출 순서를 파악할 수 없다.
// 2) 업데이트 시 깨짐
//    부모 클래스 제작자가 내부 구현을 변경하면 하위 클래스가 예기치 않게 오작동할 수 있다.
// 3) 테스트 불가능
//    부모의 동작을 모르면 자식이 어떤 상황에서 깨질지 테스트로 포착하기 어렵다.
// 4) 의도되지 않은 호출 순서
//    부모가 자기 메서드 안에서 다른 메서드를 호출할 수 있는데,
//    그게 하위 클래스가 오버라이드한 메서드일 수 있다.
//    "self-use problem"이라 부른다.
// - 상속은 "계약"이 아니라 "구현"을 재사용하는 방식이다.
//   즉 상속은 부모 클래스의 내부 구현 세부사항까지 함께 끌어안는 것이기에 문제가 된다.
//
//

package effectivejava.ch04.item18.exam03;

// [주제] 상속이 위험한 이유 3 - 하위 클래스에 이미 존재하는 메서드를 부모 클래스에서 추가할 때 컴파일 오류가 발생한다.

class MyList<E> {
  public void add(E e) {}

  // 하위 클래스가 존재한 상태에서,
  // 만약 부모 클래스에서 하위 클래스에 존재하는 메서드와 동일한 시그너처의 메서드를 추가한다면?
  // (메서드 시그너처는 같고 반환 타입만 다른 경우)
  // - 이 클래스를 상속 받은 모든 하위 클래스에서 컴파일 오류가 발생한다.
  // public boolean add(E e1, E e2) {}
}

class MyChildList<E> extends MyList<E> {
  public void add(E e1, E e2) {}
}

public class Test {

  public static void main(String[] args) throws Exception {
    MyChildList<String> list = new MyChildList<>();
    list.add("Hello"); // 원소를 추가할 수 있는지 조건을 확인한다.
    list.add("World"); // 원소를 추가할 수 있는지 조건을 확인한다.

    // [문제의 원인]
    // - 메서드 재정의(overriding)은,
    //   상위 메서드의 시그너처(이름, 매개변수 목록)이 같아야 하고,
    //   리턴 타입은 같거나 하위 타입이어야 한다.
  }
}
