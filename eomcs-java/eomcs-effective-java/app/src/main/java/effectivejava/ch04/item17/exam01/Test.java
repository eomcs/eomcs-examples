// # 아이템 17. 변경 가능성을 최소화하라
// - 불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스다.
//   불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
//   - 불변 클래스의 예: String, Wrapper 클래스들, BigInteger, BigDecimal, java.time 패키지의 클래스들
// - 불변 클래스의 장점
//   1. 단순성: 불변 클래스는 설계, 구현, 사용이 단순하다.
//   2. 안전성: 불변 클래스는 내부 상태가 바뀌지 않으므로, 공유해도 안전하다.
//   3. 해시코드 캐싱: 불변 클래스는 해시코드를 캐싱해두고 재사용할 수 있다.
//   4. 방어적 복사 불필요: 불변 클래스는 방어적 복사를 할 필요가 없다.
// - 불변 클래스를 만드는 방법
//   1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
//   2. 클래스를 확장할 수 없도록 한다.
//      하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다.
//      클래스를 final로 선언하거나 생성자를 private으로 선언한다.
//   3. 모든 필드를 final로 선언한다.
//      시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법이다.
//      새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장한다.
//      (Java Language Spec. 17.5절 참조)
//   4. 모든 필드를 private으로 선언한다.
//      필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 변경하는 것을 막아준다.
//      기본 타입 필드나 불변 객체를 참조하는 필드에 대해서는 public final로만 선언해도 불변 객체가 된다.
//      하지만, 추후 내부 표현을 바꾸지 못하는 문제가 있으므로 권하지 않는다.
//   5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
//      클래스에 가변 객체를 참조하는 필드가 하나라도 있다면
//      클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.
//      이런 필드는 절대 클라이언트가 제공한 객체 참조를 가리키게 해서는 안되며,
//      접근자 메서드가 그 필드를 그대로 반환해서도 안된다.
//      왜? 클라이언트(호출자)가 그 객체를 변경할 수 있기 때문이다. 그러면 불변성이 깨진다.
//      생성자, 접근자, readObject() 메서드 모두에서 방어적 복사를 수행하라.

package effectivejava.ch04.item17.exam01;

// [주제]
// 불변 클래스 만들 때 필드를 final 로 선언하는 이유
// - 공개된 객체를 사용할 때 값이 초기화 되었다는 것을 보장한다.

class MyObject {
  private final int x;
  private int y;

  public MyObject() {
    this.x = 3;
    this.y = 4;
  }

  private static MyObject obj;

  public static void write() {
    obj = new MyObject();
  }

  public static void read() {
    if (obj != null) {
      int i = obj.x; // x는 final 필드이므로, obj를 통해 이 필드에 접근할 때 항상 초기화가 완료된 값을 읽는다.
      int j = obj.y; // y는 변경 가능 필드이므로, obj를 통해 이 필드에 접근할 때 초기화가 완료되기 전의 값을 읽을 수도 있다.
    }
  }
}

public class Test {
  public static void main(String[] args) throws Exception {
    Thread t1 = new Thread(() -> MyObject.write());
    Thread t2 = new Thread(() -> MyObject.read());

    t1.start();
    t2.start();
    // t1 스레드가 write() 메서드를 실행하여 인스턴스를 생성하는 동안
    // t2 스레드가 read() 메서드를 실행하여 obj 필드를 읽을 때,
    // obj 필드가 null이 아닌 상태가 되었다고 하더라도
    // MyObject 인스턴스의 x 필드 값은 완전히 초기화된 상태이지만
    // y 필드는 아직 초기화되지 않은 상태일 수 있다.
    // 생성자 호출을 완료했는데 어떻게 y 필드가 초기화되지 않을 수 있을까?
    // 그 이유는 CPU 캐시, 레지스터, 명령어 재배치 때문이다.

    // [final 필드 초기화 규정(JLS, 17.5. final Field Semantics)]
    // - final 필드의 값은 생성자 호출이 끝나기 전에 반드시 초기화가 완료된다.
    // - 다른 스레드가 레퍼런스를 획득한 후에 final 필드의 값을 읽을 때, 그 값이 초기화된 상태임이 보장된다.
    // - 일반 필드는 생성자 호출이 끝난 후에도 초기화 되어 있지 않을 수 있다.
    //   왜? CPU 캐시, 레지스터, 명령어 재배치 때문이다.

    // [final 필드 초기화 과정]
    // 1. 인스턴스 메모리 할당
    // 2. 모든 final 필드에 대해 생성자의 초기화 문장이 실행된다.
    // 3. 생성자 끝 --> 메모리 장벽
    //    메모리 장벽? 객체가 공개된 후 "다른 스레드에도 반드시 보이도록" 가시성을 보장한다는 의미
    // 4. 참조 발행 (예: f = new Foo(...);)
    // - 일반 필드는 1번 이후에 생성자의 초기화 문장이 실행된다.
    //   명령어 재배치에 따라 그 순서가 결정된다.
    //   즉 참조가 발생되기 전에 초기화 된다는 것을 보장하지 않는다.

    // [명령어 재배치]
    // - 컴파일러, JVM, CPU가 프로그램 실행 효율을 높이기 위해 명령어의 실행 순서를 바꾸는 것
    // - 명령어 재배치가 일어나더라도, 단일 스레드 환경에서는 프로그램의 실행 결과가 바뀌지 않는다.
    // - 하지만, 멀티 스레드 환경에서는 문제가 될 수 있다.

    // [명령어 재배치 예시]
    // 소스 코드:
    // public static void write() {
    //    obj = new MyObject();
    // }
    //
    // 컴파일러가 재배치한 코드:
    // - 시나리오 1: 이 경우 다른 스레드가 obj를 읽으면 x는 3이고, y는 0이 된다.
    // public static void write() {
    //    STORE x, 3         // final 필드
    //    <메모리 장벽>       // 생성자 끝
    //    STORE obj, 객체주소
    //    --> 다른 스레드가 obj를 읽을 때
    //    STORE y, 4         // 일반 필드
    // }
    //
    // - 시나리오 2: 이 경우 다른 스레드가 obj를 읽으면 x는 3이고, y는 4가 된다.
    // public static void write() {
    //    STORE y, 4         // 일반 필드
    //    STORE x, 3         // final 필드
    //    <메모리 장벽>       // 생성자 끝
    //    STORE obj, 객체주소
    //    --> 다른 스레드가 obj를 읽을 때
    // }
    //
    // - 시나리오 3: 이 경우 다른 스레드가 obj를 읽으면 x는 3이고, y는 4가 된다.
    // public static void write() {
    //    STORE x, 3         // final 필드
    //    <메모리 장벽>       // 생성자 끝
    //    STORE y, 4         // 일반 필드
    //    STORE obj, 객체주소
    //    --> 다른 스레드가 obj를 읽을 때
    // }

  }
}
