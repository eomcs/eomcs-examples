// # 아이템 18. 상속보다는 컴포지션을 사용하라
// - 상속은 코드를 재사용하는 강력한 수단이지만, 남용하면 오히려 해가 된다.
// - 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이다.
// - 확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 안전하다.
// - 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 사용하라.
//   하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다.
// - 상속의 취약점을 피하는 방법은 컴포지션과 전달을 사용하는 것이다.
//
// [상속이 위험한 경우] 다른 패키지의 구체(concrete) 클래스를 상속할 때
// 1) 내부 구현을 알 수 없음
//    부모 클래스의 private 필드, protected 메서드, 호출 순서를 파악할 수 없다.
// 2) 업데이트 시 깨짐
//    부모 클래스 제작자가 내부 구현을 변경하면 하위 클래스가 예기치 않게 오작동할 수 있다.
// 3) 테스트 불가능
//    부모의 동작을 모르면 자식이 어떤 상황에서 깨질지 테스트로 포착하기 어렵다.
// 4) 의도되지 않은 호출 순서
//    부모가 자기 메서드 안에서 다른 메서드를 호출할 수 있는데,
//    그게 하위 클래스가 오버라이드한 메서드일 수 있다.
//    "self-use problem"이라 부른다.
// - 상속은 "계약"이 아니라 "구현"을 재사용하는 방식이다.
//   즉 상속은 부모 클래스의 내부 구현 세부사항까지 함께 끌어안는 것이기에 문제가 된다.
//
//

package effectivejava.ch04.item18.exam02;

// [주제] 상속이 위험한 이유 2 - 부모 클래스에 새 메서드 추가하면 하위 클래스가 깨질 수 있다.

class MyList<E> {
  public void add(E e) {}

  // 만약 부모 클래스에 다음과 같은 메서드가 추가된다면?
  // - 이 클래스를 상속받은 하위 클래스는 이 메서드를 재정의해야 한다.
  //   예) MyChildList는 add(E)처럼
  //      특별한 조건에서만 원소를 추가하도록 add(E, E)를 재정의해야 한다.
  // public void add(E e1, E e2) {}
}

class MyChildList<E> extends MyList<E> {
  @Override
  public void add(E e) {
    // 특별한 조건을 만족할 때만 추가, 그 밖에는 무시
    super.add(e);
  }
}

public class Test {

  public static void main(String[] args) throws Exception {
    MyChildList<String> list = new MyChildList<>();
    list.add("Hello"); // 원소를 추가할 수 있는지 조건을 확인한다.
    list.add("World"); // 원소를 추가할 수 있는지 조건을 확인한다.

    // 만약 부모 클래스에 add(E, E) 메서드가 추가되었고,
    // MyChildList가 이 메서드를 재정의하지 않았다면?
    // list.add("Hello", "World"); // 조건을 확인하지 않고 원소가 추가된다.
    // - 이것은 하위 클래스의 동작을 깨뜨린다.
  }
}
