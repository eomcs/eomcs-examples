// # 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
// [상속을 고려한 설계]
// 1) 문서화
// - 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.
//   상속용 클래스는 재정의할 수 있는 메서드를 내부적으로 어떻게 이용하는지(self-use) 문서로 남겨야 한다.
// - API로 공개된 메서드에서 자신의 또 다른 메서드를 호출(self-use)할 경우,
//   어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 미치는지 문서로 남겨야 한다.
// - 즉, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
// 2) protected 메서드/필드
// - 효율 좋은 하위 클래스를 만들 수 있도록 클래스의 내부 동작 과정에 끼어들 수 있는 훅(hook)을 잘 선별하여
//   protected 로 공개해야 할 수도 있다.
//   (드물게 protected 필드로 공개해야 할 수도 있다.)
//   예) java.util.AbstractList의 removeRange() 메서드
// 3) 생성자, clone(), readObject()
// - 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
//   상위 클래스가 생성자가 하위 클래스의 생성자보다 먼저 실행되기 때문에,
//   재정의한 메서드가 하위 클래스의 생성자가 초기화하는 값에 의존한다면 문제가 발생할 것이다.
// - clone()이나 readObject()도 생성자와 비슷한 효과를 내기 때문에,
//   이 메서드에서도 직.간접적으로 재정의 가능 메서드를 호출해서는 안된다.
//
// 이렇게 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당하다.
//
// [상속으로 발생하는 문제를 피하는 가장 좋은 방법]
// "상속용으로 설계하지 않은 클래스는 상속을 금지"하는 것이다.
//
// [상속이 캡슐화를 해치는 현상]
// - '좋은 API 문서란', '어떻게'가 아니라 '무엇'을 하는지를 설명해야 한다.
//   즉 클라이언트 입장에서는 내부 구현이 어떻게 되었는지 알 필요가 없다.
// - 그런데 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.
// - 이것은 상속이 캡슐화를 깨뜨린다는 것을 증명하는 대표적인 사례이다.

package effectivejava.ch04.item19.exam02;

// [주제] 상속을 고려한 설계: 생성자는 직.간접적으로 재정의 가능 메서드를 호출할 때 발생하는 문제점 확인

// [상속용 클래스]
class Super {
  Super() {
    overrideMe(); // 생성자에서 재정의 가능 메서드를 호출하고 있다.
  }

  void overrideMe() {}
}

// [하위 클래스]
class Sub extends Super {
  private final int value;

  Sub() {
    // super(); // 하위 클래스의 생성자가 실행되기 전에 슈퍼클래스의 생성자가 먼저 실행된다.
    value = 42;
  }

  @Override
  void overrideMe() {
    System.out.println(value);
  }
}

public class Test {
  public static void main(String[] args) throws Exception {
    Sub sub = new Sub();
    sub.overrideMe();
    // 1. Sub 클래스의 인스턴스를 생성한다.
    // 2. Sub 클래스의 생성자가 호출된다.
    // 3. Sub 클래스의 생성자는 첫 줄에서 슈퍼클래스인 Super 클래스의 생성자를 호출한다.
    // 4. Super 클래스의 생성자가 실행된다.
    // 5. Super 클래스의 생성자에서 재정의 가능 메서드인 overrideMe()를 호출한다.
    //    이때, overrideMe() 메서드는 Sub 클래스에서 재정의한 메서드가 호출된다.
    //    출력 값: 0
    //    이유: Sub 클래스의 생성자는 아직 실행되지 않았고, 따라서 value 필드는 초기화되지 않았다.
    //         자바는 인스턴스 필드를 초기화하지 않은 상태에서 기본값(0)으로 초기화한다.
    // 6. Super 클래스의 생성자가 종료된다.
    // 7. Sub 클래스의 생성자가 실행된다.
    // 8. Sub 클래스의 생성자에서 value 필드를 42로 초기화한다.
    // 9. Sub 클래스의 생성자가 종료된다.
    // 10. main() 메서드에서 sub.overrideMe()를 호출한다.
    //     출력 값: 42
    //     이유: Sub 클래스의 생성자가 실행되었고, 따라서 value 필드는 42로 초기화되었다.

    // [정리]
    // - 생성자에서 재정의 가능 메서드를 호출하는 것은 매우 위험하다.
    // - 재정의 가능 메서드가 하위 클래스에서 재정의되었을 때,
    //   그 메서드가 하위 클래스의 생성자가 실행되기 전에 호출될 수 있기 때문이다.
    // - 이 경우 재정의한 메서드가 초기화되지 않은 필드에 접근할 수 있다.
    // - 따라서 상속용 클래스를 설계할 때는 생성자, clone(), readObject()에서
    //   재정의 가능 메서드를 직접.간접적으로 호출해서는 안된다.

    // [일반 concrete 클래스의 위험성]
    // - 일반적인 concrete 클래스는 final도 아니고 상속용으로 설계되거나 문서화되지 않았다.
    // - 특별히 상속 불가능하게 조치를 취해놓지 않으면 누군가가 상속을 시도할 것이다.
    // - 이것은 추후에 큰 골칫거리가 될 수 있다.
    //   즉 클래스에 변화가 생길 때마다 하위 클래스들을 오동작하게 만들 수 있다.
    //   클래스 내부만 수정했음에도 하위 클래스에서 문제가 생겼다는 버그 리포트를 받는 일이 드물지 않다.
    // - 상속용으로 설계하지 않은 클래스는 상속을 금지하라.
    //   클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다.

    // [표준인터페이스를 구현하지 않은 일반 concrete 클래스를 상속하고 싶을 때]
    // - 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 문서로 남겨라.
    // - 재정의 가능 메서드를 호출하는 자기 사용 코드(self-use)를 완벽히 제거해야 한다.
    //   이렇게 하면 상속도 그리 위험하지 않은 클래스가 된다.
    //   메서드를 재정의해도 다른 메서드의 동작에 아무런 영향을 주지 않는다.

    // [재정의 가능 메서드 제거법]
    // - 재정의 가능 메서드 각각에 대해 본문 코드를 'private 도우미 메서드'로 옮긴다.
    // - 재정이 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하게 한다.

    // [상속을 금지하는 방법]
    // 1) 클래스를 final로 선언한다.
    // 2) 모든 생성자를 private이나 package-private으로 선언하고,
    //    public 정적 팩토리를 만들어준다.
    // - 핵심 기능을 정의한 인터페이스가 있고, 그 인터페이스를 구현했다면
    //   상속을 금지해도 개발하는데 아무런 어려움이 없을 것이다.
    // - 상속 대신 래퍼 클래스 패턴을 사용하는 것이 더 나은 대안이다.

  }
}
