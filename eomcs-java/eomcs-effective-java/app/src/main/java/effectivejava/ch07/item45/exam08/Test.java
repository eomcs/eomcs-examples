// # 아이템 45. 스트림은 주의해서 사용하라
// [핵심 개념]
// - 스트림(stream): 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.
// - 스트림 파이프라인: 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.
// - 스트림 원소 제공지: 컬렉션, 배열, 파일, 정규표현식 패턴 매처, 난수 생성기, 다른 스트림 등
// - 스트림 원소 타입: 객체 레퍼런스, 기본 타입(int, long, double)
//
// [스트림 파이프라인]
// - 소스 스트림에서 시작해 종단 연산으로 끝난다.
// - 중간 연산(intermediate operation)
//   - 시작과 종단 사이에 하나 이상의 있을 수 있다.
//   - 스트림을 어떠한 방식으로 변환(transform)한다.
//   - 각 원소에 함수를 적용하거나 특정 조건을 만족 못하는 원소를 걸러낼 수 있다.
// - 중간 연산의 결과물
//   - 변환된 원소 타입은 변환 전 원소 타입과 같을 수도 있고 다를 수도 있다.
// - 종단 연산(terminal operation)
//   - 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다.
//   - 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력하는 식이다.
//   - 종단 연산이 없으면, 아무 일도 하지 않는다. 빼먹는 일이 절대 없도록 하자.
//
// [지연 평가(lazy evaluation)]
// - 스트림의 파이프라인은 지연 평가된다.
// - 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
// - 이러한 지연 평가가 무한 스트림을 다룰 수 있게 해주는 열쇠다.
//
// [스트림 API]
// - 스트림 API는 다량의 데이터 처리 작업을 돕는 API이다.
// - 메서드 연쇄를 지원하는 플루언트 API(fluent API)이다.
// - 파이프라인 하나를 구성하는 모든 호출을 연결하여 단 하나의 표현식으로 완성할 수 있다.
// - 파이프라인 여러 개를 연결해 표현식 하나로 만들 수도 있다.
//
// [병렬 스트림(parallel stream)]
// - 기본적으로 스트림 파이프라인은 순차적으로 수행된다.
// - 병렬로 실행하려면 파이프라인을 구성하는 스트림 중 하나에서 parallel() 메서드를 호출하면 된다.
//   그러나 효과를 볼 수 있는 상황이 많지 않다.
//
// 스트림을 제대로 사용하면 프로그램이 짧고 깔끔해지지만,
// 잘못 사용하면 읽기 어렵고 유지보수도 힘들어진다.

package effectivejava.ch07.item45.exam08;

// [주제] 스트림으로 처리하기 어려운 일
// - 한 데이터가 파이프라인의 여러 단계를 통과할 때 이 데이터의 각 단계에서의 값들에 동시에 접근하기는 어렵다.
// - 스트림 파이프라인은 일단 한 값을 다른 값에 매핑하고 나면 원래의 값을 잃는 구조이기 때문이다.
// - 원래 값과 새로운 값의 쌍을 저장하는 객체를 사용해 매핑하는 우회 방법고 있겠지만, 만족스러운 해법은 아니다.
// - 앞 단계의 값이 필요할 때 매핑을 꺼꾸로 수행하는 방법이 있다.
//
import static java.math.BigInteger.TWO;

import java.math.BigInteger;
import java.util.stream.Stream;

public class Test {

  // 스트림을 반환하는 메서드의 이름은 원소의 정체를 알려주는 복사 명사를 사용하라.
  // - 스트림 파이프라인의 가독성이 크게 좋아질 것이다.
  static Stream<BigInteger> primes() {
    // 무한 스트림이므로 limit() 같은 종단 연산이 반드시 필요하다.
    return Stream.iterate(
        TWO, // 첫 번째 원소를 seed로 두고
        BigInteger::nextProbablePrime // 이후 원소들을 생성하는 함수. 현재 값보다 큰 다음 소수를 반환한다.
        );
  }

  public static void main(String[] args) {
    // 메르센 소수를 출력하는 프로그램
    // - 메르센 소수: 2^p - 1의 꼴로 나타낼 수 있는 소수
    primes()
        // 2, 3, 5, 6, 11, 13, 17, ...
        .map(p -> TWO.pow(p.intValueExact()).subtract(BigInteger.ONE))
        // 2^p - 1 (p는 소수)
        .filter(mersenne -> mersenne.isProbablePrime(50))
        // 확률적으로 소수 여부를 검사. certainty가 50이면, 1/2^50 확률로 잘못된 결과를 낼 수 있다.
        // 즉 거의 확실한 "소수 판정"이라고 보면 된다.
        .limit(20)
        // 무한 스트림을 20개의 원소까지만 제한한다.
        .forEach(System.out::println); // 최종적으로 출력한다.
    System.out.println("----------------------------------------");

    // [최종 결과 값이 아닌 중간 결과 값을 얻고 싶을 때]
    // - 메르센 소수의 앞에 지수(p)를 출력하려면,
    //   첫 번째 중간 연산에서 수행한 매핑을 꺼꾸로 수행해 메르센 수의 지수를 쉽게 계산해낼 수 있다.
    primes()
        .map(p -> TWO.pow(p.intValueExact()).subtract(BigInteger.ONE))
        .filter(mersenne -> mersenne.isProbablePrime(50))
        .limit(20)
        .forEach(mp -> System.out.println(mp.bitLength() + ": " + mp));
    // 종단 연산에서 매핑을 꺼꾸로 수행한다.
  }
}
