// # 아이템 48. 스트림 병렬화는 주의해서 적용하라
// [자바의 동시성 프로그래밍 역사]
// - 자바 1.0: 스레드와 동기화 제공
// - 자바 1.5: java.util.concurrent 라이브러리 + 실행자(Executor) 프레임워크 추가
// - 자바 1.7: 고성능 병렬 분해 프레임워크(Fork/Join) 추가
// - 자바 1.8: 스트림 병렬화 추가
//
// [동시성 프로그래밍의 어려움]
// - 안정성과 응답 가능 상태를 유지하면서 여러 스레드가 공유 자원을 안전하게 접근하도록 만드는 것은 매우 어렵다.
// - 안정성이란?
//   여러 스레드가 동시에 공유자원을 접근했을 때 스레드 상호간 값을 덮어 쓰지 않도록 작업의 순차성을 보장하는 것.
//   예) synchronized void increment() { count++; }
// - 응답 가능 상태란?
//   여러 스레드가 동시에 공유자원을 접근했을 때 교착 상태에 빠지지 않고 적절한 시간 내에 작업을 완료하는 것.
//   예) 데드락(deadlock), 활주(lock contention), 무한 대기 등의 문제를 방지.
// - "데이터를 보호하기 위해 lock을 걸면 응답성이 떨어지고, 응답성을 높이려 lock을 줄이면 안정성이 깨진다."
//

package effectivejava.ch07.item48.exam02;

// [주제] 스트림 병렬화 사용 후

import static java.math.BigInteger.ONE;
import static java.math.BigInteger.TWO;

import java.math.BigInteger;
import java.util.stream.Stream;

public class Test {
  public static void main(String[] args) {
    // 실행이 느려진다.
    // 출력하더라도 순서가 올바르지 않을 수 있다.
    primes()
        .parallel() // 스트림 병렬화 적용
        .map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
        .filter(mersenne -> mersenne.isProbablePrime(50))
        .limit(10)
        .forEach(System.out::println);

    // [원인]
    // - 스트림 라이브러리가 이 파이프라인을 병렬화하는 방법을 찾아내지 못했기 때문이다.
    // - 데이터 소스가 Stream.iterate() 이거나,
    //   중간 연산으로 limit()을 사용하면 파이프라인 병렬화로는 성능을 개선할 수 없다.
    //   위 코드는 이 두가지 문제를 모두 지니고 있다.
    //   1) iterate():
    //      병렬 스트림은 데이터를 여러 덩어리로 쉽게 분할해야 이득이 나는데, iterate()는 분할이 어렵다.
    //   2) limit(20):
    //      병렬로 여러 스레드가 실행될 때 "전체에서 처음 20개"를 맞추려면 스레드 간 조율이 필요하다.
    //   즉 조율/합치기 비용 + 순서 보장 때문에 이득이 상쇄된다.
    //
    // [병렬화 조건]
    // - 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap 의 인스턴스거나,
    //   배열, int 범위(IntStream.range()), long 범위일 때 병렬화 효과가 가장 좋다.
    // - 즉 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있는 자료구조여야,
    //   여러 스레드에 효과적으로 분배하기 쉽다.
    //   나누는 작업은 Spliterator가 담당한다.
    //   Spliterator객체는 Stream이나 Iterable의 spliterator()메서드를 호출해 얻을 수 있다.
    // - 이들 자료구조의 중요한 공통점은 원소들을 순차적으로 실행할 때 참조 지역성이 뛰어나다는 것이다.
    //   즉 이웃한 원소들이 메모리상에 가까이 위치해 있어 캐시 효율이 높다.
    // - 스트림 안의 원소 수와 원소당 수행되는 코드 줄 수를 곱한 결과가
    //   수십만 이상일 때 병렬화를 통한 성능 향상을 맛볼 수 있다.
    // - 조건이 잘 갖춰지면 paralle() 호출 하나로 프로세서 코어 수에 비례하는 성능 향상을 꾀할 수 있다.
    //   머신러닝과 데이터 처리 같은 특정 분야에서 특히 그렇다.
    //
    // [참조 지역성]
    // - 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송될 때까지 기다리게 된다.
    // - 참조 지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 아주 중요하다.
    // - 참조 지역성이 뛰어난 자료구조는 기본 타입의 배열이다.
    //   기본 타입 배열은 데이터 자체가 메모리에 연속해서 저장된다.
    //
    // [종단 연산과 병렬화]
    // - 정단 연산의 작업량이 파이프라인 전체 작업에서 상당 비중을 차지하면서 순차적인 연상이라면,
    //   파이프라인 병렬 수행의 효과는 제한된다.
    // - 종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction) 연산이다.
    //   예) reduce 종류 메서드, sum(), max(), min(), count() 같이 완성된 형태로 제공되는 메서드.
    // - 조건에 맞으면 바로 반환되는 메서드는 병렬화에 적합한다.
    //   예) anyMatch(), allMatch(), noneMatch()도 병렬화에 적합하다.
    // - 가변 축소를 수행하는 종단 연산은 병렬화에 부적합하다.
    //   예) collect()는 병렬화에 부적합하다.
    //   왜? 컬렉션들을 합치는 부담이 크기 때문이다.
    //
    // [병렬화 팁]
    // - 직접 구현한 Stream, Iterable, Collection 이 병렬화의 이점을 제대로 누리려면
    //   spliterator() 메서드를 반드시 재정의하고 결과 스트림의 병렬화 성능을 강도 높게 테스트하라.
    // - 출력 순서를 순차 버전으로 정렬하고 싶다면, forEachOrdered()를 사용하라.
    // - 운영환경과 비슷한 환경에서 테스트하라.
    //
    // [병렬화 시 주의할 점]
    // - 스트림을 잘못 병렬화하면 응답 불가를 포함해 성능이 나빠질 뿐만아니라,
    //   결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.
    // - 결과가 잘못되거나 오동작하는 것을 "안전 실패(safety failure)"라고 부른다.
    //   병렬화한 파이프라인이 사용하는 filters, mappers, 혹은 프로그래머가 제공하는 함수 객체가
    //   명세대로 동작하지 않을 때 발생할 수 있다.
    //
    // [스트림에서 사용되는 함수 객체의 규약]
    // - Stream의 reduce 연산에 건네지는 accumulator와 combiner 함수는
    //   반드시 결합법칙을 만족하고, 간섭받지 않고, 상태를 갖지 않아야 한다.
    //   - 결합법칙: (a op b) op c == a op (b op c)
    //   - 간섭받지 않음: 스트림이 처리되는 동안 외부에서 스트림의 원소를 변경하지 않음.
    // - 이 규약을 지키지 않으면 병렬화한 스트림 파이프라인이 안전 실패를 일으킬 수 있다.

  }

  static Stream<BigInteger> primes() {
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
  }
}
