// # 아이템 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라
// - 프로그램의 동작을 스레드 스케줄러에 기대지 말라.
//   결고성과 이식성을 모두 해치는 행위다.
// - 마찬가지로 Thread.yield()와 스레드 우선순위에 의존해서도 안 된다.
//   이 기능들은 스레드 스케줄러에 제공하는 힌트일 뿐이다.
// - 스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓰일 수 있지만,
//   간신히 동작하는 프로그램을 '고치는 용도'로 사용해서는 절대 안 된다.
//
// [이유]
// - 스레드 스케줄러는 운영체제마다 다르며, 심지어 같은 운영체제라도 버전에 따라 다를 수 있다.
//   따라서 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면,
//   다른 플랫폼에 이식하기 어렵다.
//
// [견고하고 빠릿하고 이식성 좋은 프로그램을 작성하는 가장 좋은 방법]
// - 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다.
//   그래야 스레드 스케줄러가 고민할 거리가 줄어든다.
// - 실행 준비가 된 스레드들은 맡은 작업을 완료할 때까지 계속 실행되도록 만들자.
//   이런 프로그램이라면 스레드 스케줄링 정책에 상관없이 잘 동작할 것이다.
//
// [실행 가능한 스레드 수를 적게 유지하는 방법]
// - 스레드는 "실행 가능한 스레드"와 "대기 중인 스레드"로 구분된다.
// - 스레드가 무언가 유용한 작업을 완료한 후에는 다음 일거리가 생길 때까지 대기하도록 만들자.
// - 스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안된다.
//   실행자 프레임워크를 예로 들면,
//   스레드 풀의 크기를 적절히 설정하고 작업은 짧게 유지하면 된다.
//   단 너무 짧으면 작업을 분배하는 부담이 오히서 성능을 떨어뜨릴 수 있다.
//

package effectivejava.ch11.item84.exam01;

// [주제] 바쁜 대기(busy waiting) 상태의 스레드 예
// - 스레드는 절대 바쁜 대기 상태에 빠져서는 안 된다.
//   공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안된다.
// - 바쁜 대기는 스레드 스케줄러의 변덕에 취약할 뿐 아니라,
//   프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다.
//
class SlowCountDownLatch {
  private int count;

  public SlowCountDownLatch(int count) {
    if (count < 0) {
      throw new IllegalArgumentException("count < 0");
    }
    this.count = count;
  }

  public void await() {
    // 이 메서드를 호출하는 스레드는 바쁜 대기 상태가 된다.
    // 즉 공유 객체의 상태가 바뀔 때까지 쉬지 않고 반복하며 검사를 수행한다.
    // 이것은 시스템 전체 성능을 떨어뜨린다.
    while (true) {
      synchronized (this) {
        if (count == 0) {
          return;
        }
      }
    }
  }

  public synchronized void countDown() {
    if (count > 0) {
      count--;
    }
  }
}

public class Test {

  public static void main(String[] args) {
    // [Thread.yield()]
    // - 특정 스레드가 다른 스레드에 비교해 CPU 시간을 충분히 얻지 못해서
    //   간신히 돌아가는 프로그램을 보더라도,
    //   Thread.yield()를 써서 문제를 고쳐보려는 유혹을 떨쳐내자.
    // - 증상이 어느 정도는 호전될 수 있지만, 이식성에 문제가 발생한다.
    //   다음 버전의 JVM에서 아무 효과가 없거나 오히려 느려질 수 있다.
    // - Thread.yield()는 테스트할 수단도 없다.
    // - 애플리케이션 구조를 바꿔 동시에 실행 가능한 스레드 수가 적어지도록 조치하라.

    // [스레드 우선순위]
    // - 스레드 우선순위를 조절하는 방법도 Thread.yield()와 마찬가지로 이식성이 떨어진다.
    //   자바에서 이식성이 가장 나쁜 특성에 속한다.
    // - 심각한 응답 불가 문제를 스레드 우선순위로 해결하려는 시도는 절대 합리적이지 않다.
    // - 진짜 원인을 찾아 수정하기 전까지 같은 문제가 반복해서 터져 나올 것이다.
  }
}
