// # 아이템 71. 필요 없는 검사 예외 사용은 피하라
// - 검사 예외를 싫어하는 개발자가 많지만, 제대로 활용하면 API와 프로그램의 질을 높일 수 있다.
// - 결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리,
//   검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다.
// - 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다.
//   검사 예외를 던지는 메서드를 호출한다면,
//   호출하는 쪽에서 반드시 예외를 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다.
// - 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없다.
//   스트림 안에서 검사 예외를 던지는 메서드를 사용하려면
//   예외를 포장하는 래퍼 메서드를 만들어야 한다.
//
// [예외를 던지는 가이드라인]
// 1) API 호출자가 예외 상황에서 복구할 방법이 없다면,
//    비검사 예외를 던져라.
// 2) 복구가 가능하고 호출자가 그 처리를 해주길 바란다면,
//    우선 옵셔널을 반환해도 될지 고민하라.
// 3) 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만
//    검사 예외를 던져라.
//
package effectivejava.ch10.item71.exam02;

// [주제] 검사 예외를 회피하는 방법 II - 메서드를 2개로 쪼개 비검사 예외로 만들기

public class Test {

  // 1) 예외를 던지는지 확인하는 메서드
  static boolean isDivisible(int x, int y) {
    return y != 0;
  }

  // 2) 실행하는 메서드
  static int divide(int x, int y) {
    return x / y;
  }

  public static void main(String[] args) throws Exception {
    int x = 10, y = 2;

    if (isDivisible(x, y)) {
      System.out.println("result1 = " + divide(10, 2));
    } else { // 예외 상황에 대비한다.
      System.out.println("0으로 나눌 수 없습니다.");
    }

    // [정리]
    // - 이 방식은 모든 검사 예외에 적용할 수 있는 것은 아니다.
    //   적용할 수 있다면 더 쓰기 편한 API를 제공할 수 있다.
    // - API가 딱히 더 아름답진 않지만, 유연한 것은 확실하다.
    //   예) 프로그래머가 이 메서드가 성공하리라는 것을 알거나, 실패 시 중단하길 원한다면,
    //      단지 다음과 같이 호출할 것이다.
    //        divide(x, y);
    //   즉, 프로그래머의 선택권이 더 넓어진다.
    //   이런 한 줄짜리 호출 방식이 주로 쓰일 거로 판단되면 이 방식을 사용하는 것이 좋다.
    // - 만약, 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나,
    //   외부 요인에 의해 상태가 변할 수 있다면,
    //   이 방식은 적절하지 않다.
    // - 만약, isDivisible()이 divide()의 작업 일부를 중복수행한다면,
    //   성능에서 손해이니 이 방식이 적절하지 않다.
  }
}
