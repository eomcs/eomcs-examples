// # 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
// - 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던져라.
// - 확실하지 않다면 비검사 예외를 던져라.
// - 검사 예외도 아니고 런타임 예외도 아닌 Throwable은 정의하지도 말라.
// - 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하라.
//   예) 쇼핑몰에서 물건을 구입하는 데 카드 잔고가 부족해서 예외가 발생했다면,
//   - 예외 객체는 부족한 잔고가 얼마인지 알려주는 접근자 메서드를 제공해야 한다.
//

package effectivejava.ch10.item70.exam01;

// [주제] 검사 예외, 런타임 예외, 에러를 구분하는 지침
// 1) 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 던져라.
//    - 검사 예외를 던지면 호출하는 쪽에서 catch로 예외를 잡아 처리하거나
//      더 바깥으로 전파하도록 강제하게 된다.
//    - 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는
//      문제 상황을 API 사용자에게 알리는 역할을 한다.
//      API 설계자는 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구하는 것이다.
// 2) 프로그래밍 오류라면 런타임 예외를 던져라.
//    - 비검사 예외는 런타임과 에러 두 종류가 있다.
//      프로그램에서 잡을 필요가 없거나 잡지 말아야 한다.
//      비검사 예외를 던졌다는 것은 복구 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.
//    - 런타임 예외의 대부분은 전제 조건을 만족하지 못했을 때 발생한다.
//      전제조건 위배란? 클라이언트가 해당 API 명세에 기록된 제약을 지키지 못했다는 뜻이다.
//      예) ArrayIndexOutOfBoundsException
//    - 전제 조건에서 문제가 발생했을 때 복구할 수 있는 상황인지 아닌지는 API 설계자가 판단해야 한다.
//      메모리가 부족할 때, 잘못된 크기의 배열을 할당해 발생한 프로그래밍 오류일 수 있고,
//      일시적으로 메모리가 부족한 상황일 수 있다.
//      후자라면 검사 예외를 던져야 한다.
//      확신하기 어렵다면 비검사 예외를 던져라.
// 3) 개발자가 구현하는 비검사 예외는 모두 RuntimeException의 하위 클래스여야 한다.
//    - Error 클래스의 하위 클래스를 만들지 말라. 직접 던지지도 말라.
//      에러는 보통 JVM이 자원부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.
//    - Throwable의 하위 클래스를 만들지 말라.
//      일반 검사 예외처럼 다루지만, API 사용자를 헷갈리게 한다.
//

public class Test {
  public static void main(String[] args) throws Exception {}
}
