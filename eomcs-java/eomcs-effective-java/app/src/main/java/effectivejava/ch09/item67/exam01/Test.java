// # 아이템 67. 최적화는 신중히 하라
// [최적화 격언]
// "(맹목적인 어리석음을 포함해) 그 어떤 핑계보다 효율성이라는 이름 아래 행해진
//  컴퓨팅 죄악이 더 많다(심지어 효율을 높이지도 못하면서)." - 윌리엄 울프
//
// "(전체의 97% 정도인) 자그마한 효율성은 모두 잊자.
//  섣부른 최적화가 만악의 근원이다." - 도널드 크누스
//
// "최적화를 할 때는 다음 두 규칙을 따르라.
//  첫 번째, 하지마라.
//  두 번째, (전문가 한정) 아직 하지 마라.
//  다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지마라" - M. A. 잭슨
//
// - 이 격언들은 자바가 탄생하기 20년 전에 나온 것으로, 최적화의 어두운 진실을 얘기해준다.
// - 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 섣불리 진행하면 특히 더 그렇다.
//   빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시키는 것이다.
//

package effectivejava.ch09.item67.exam01;

// [주제] 최적화를 고민할 때 고려할 사항
// - 빠른 프로그램보다는 좋은 프로그램을 작성하라
//   성능 때문에 견고한 구조를 희생하지 말라.
//   좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다.
//   따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.
// - 성능을 제한하는 설계는 피하라.
//   완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식이다.
//   API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 대표적이다.
//   아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결 불가능하다.
//   따라서 설계 단계에서 성능을 반드시 염두에 두어야 한다.
// - API를 설계할 때 성능에 주는 영향을 고려하라.
//   public 타입이 가변 --> 데이터 변경하지 못하게 방어적 복사해야 한다.
//   컴포지션 대신 상속 --> 상위 클래스에 영원히 종속되며 그 성능과 제약까지 물려 받는다.
//   인터페이스 대신 구현 타입 사용 --> 특정 구현체에 종속되게 하여 교체가 힘들다.
// - 성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각이다.
//   성능 문제는 플랫폼이나 다음 버전에서 사라질 수 있지만,
//   왜곡된 API와 이를 지원하는 데 따르는 고통은 영원히 계속될 것이다.
// - 각각의 최적화 시도 전후로 성능을 측정하라.
//   느릴 거라고 짐작한 부분이 사실은 성능에 별다른 영향을 주지 않는 곳이라면 시간만 허비한 꼴이다.
//   일반적으로 90%의 시간을 단 10%의 코드에서 사용한다.
// - 프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는데 도움을 준다.
//   이런 도구는 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공하여,
//   집중할 곳은 물론 알고리즘을 변경해야 한다는 사실을 알려주기도 한다.
//   시스템 규모가 커질수록 프로파일러가 더 중요해진다.
//   "jmh"는 프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크다.
// - 자바는 프로그래머가 작성하는 코드와 CPU에서 수행하는 명령 사이에 '추상화 격차'가 커서
//   최적화로 인한 성능 변화를 일정하게 예측하기 어렵다.

public class Test {
  public static void main(String[] args) throws Exception {}
}
